# Story 3.2: Error Handling & Retry Logic

## Status

Ready for Done

## Story

**As a** system,
**I want** to automatically retry failed crawling attempts,
**so that** temporary issues don't result in missed content.

## Acceptance Criteria

1. Implement exponential backoff for failed requests
2. Add maximum retry limits per job
3. Log detailed error information for debugging
4. Implement circuit breaker for persistent failures
5. Send alerts for critical failures

## Tasks / Subtasks

- [X] Task 1: Implement comprehensive error handling system (AC: 1, 2, 3)
  - [X] Create error classification system with custom exception classes
  - [X] Implement exponential backoff with jitter for retry logic
  - [X] Add maximum retry limits configuration per error type
  - [X] Create structured error logging with correlation IDs
  - [X] Update existing Celery tasks to use new error handling system
- [X] Task 2: Implement circuit breaker pattern for external service calls (AC: 4)
  - [X] Create circuit breaker implementation for Google News service
  - [X] Add circuit breaker for newspaper4k extraction calls
  - [X] Implement state tracking (closed, open, half-open) with recovery timeout
  - [X] Add circuit breaker monitoring and metrics collection
  - [X] Integrate circuit breaker with existing CrawlerEngine
- [X] Task 3: Create alert system for critical failures (AC: 5)
  - [X] Implement alert configuration system with severity levels
  - [X] Create alert handlers for different notification channels
  - [X] Add alert rules for circuit breaker state changes
  - [X] Implement alert rate limiting to prevent spam
  - [X] Add alert history tracking and acknowledgment system
- [X] Task 4: Enhance Celery task error handling and recovery (AC: 1, 2, 3)
  - [X] Update crawl_category_task with comprehensive error handling
  - [X] Add differentiated retry strategies for different error types
  - [X] Implement job status tracking for failed jobs with detailed error information
  - [X] Add automatic job recovery for transient failures
  - [X] Create job failure analysis and reporting functionality
- [X] Task 5: Create comprehensive testing for error scenarios (AC: 1-5)
  - [X] Create unit tests for error classification and exception handling
  - [X] Test exponential backoff and retry logic with different failure patterns
  - [X] Test circuit breaker behavior with simulated service failures
  - [X] Create integration tests for complete error recovery workflows
  - [X] Test alert system with various failure scenarios and configurations

## Dev Notes

### Previous Story Insights

From Story 3.1 (Basic Job Scheduler):

- Existing Celery-based scheduling framework with job status tracking is available
- CrawlJob model includes retry_count, error_message fields for tracking failures
- Current task implementation has basic retry logic (max 3 retries, exponential backoff)
- CrawlJobRepository has methods for tracking job statistics and failed jobs
- Correlation IDs are implemented for request tracing across components
- Structured logging is configured with task_id, category_id, and correlation_id
- Job management CLI script exists for monitoring and maintenance

### Data Models

**Source: [architecture/data-models.md#ErrorHandling] & [architecture/error-handling.md]**

**BaseAppException Class:**

```python
class BaseAppException(Exception):
    def __init__(
        self,
        code: ErrorCode,
        message: str,
        details: Optional[Dict[str, Any]] = None,
        retryable: bool = False,
        retry_after: Optional[int] = None
    )
```

**Error Classification System:**

- **Business Logic Errors**: CATEGORY_NOT_FOUND, CATEGORY_VALIDATION_FAILED, INVALID_KEYWORDS
- **External Service Errors**: GOOGLE_NEWS_UNAVAILABLE, RATE_LIMIT_EXCEEDED, EXTRACTION_FAILED
- **Infrastructure Errors**: DATABASE_CONNECTION_ERROR, REDIS_CONNECTION_ERROR, CELERY_TASK_FAILED
- **Generic Errors**: INTERNAL_SERVER_ERROR, VALIDATION_ERROR

**CircuitBreaker State Model:**

- **States**: closed (normal operation), open (failing fast), half-open (testing recovery)
- **Configuration**: failure_threshold (default 5), recovery_timeout (default 300s)
- **Tracking**: failure_count, last_failure_time, success_count

**Alert Configuration Model:**

- **Severity Levels**: LOW, MEDIUM, HIGH, CRITICAL
- **Channels**: email, webhook, log_only
- **Rate Limiting**: max_alerts_per_hour, cooldown_period
- **Rules**: error_codes to monitor, circuit_breaker_states, threshold_configurations

### API Specifications

**Source: [architecture/error-handling.md#CustomExceptionClasses]**

**Enhanced Celery Task Error Handling:**

```python
@celery_app.task(bind=True, max_retries=3)
def crawl_category_task(self, category_id: str, job_id: str):
    try:
        # Task execution logic
    except RateLimitExceededError as e:
        # Immediate retry with specified delay
        raise self.retry(countdown=e.retry_after or 60)
    except ExternalServiceError as e:
        # Exponential backoff for external service failures
        countdown = min(60 * (2 ** self.request.retries), 300)
        raise self.retry(countdown=countdown)
    except Exception as e:
        # Log and fail for unexpected errors
        logger.error("Task failed with unexpected error")
        raise
```

**Circuit Breaker Integration:**

```python
class CircuitBreakerManager:
    async def call_with_circuit_breaker(
        self,
        service_name: str,
        func: Callable,
        *args,
        **kwargs
    ) -> Any:
        """Execute function with circuit breaker protection"""
```

**Alert System API:**

```python
class AlertManager:
    async def send_alert(
        self,
        alert_type: AlertType,
        severity: AlertSeverity,
        message: str,
        details: Dict[str, Any],
        correlation_id: str
    ) -> bool:
        """Send alert through configured channels"""
```

### Component Specifications

**Source: [architecture/backend-architecture.md] & [architecture/source-tree.md]**

**Files to Create:**

- `src/shared/exceptions.py` - Enhanced custom exception classes with error classification
- `src/core/error_handling/` - New error handling module
  - `circuit_breaker.py` - Circuit breaker implementation
  - `retry_handler.py` - Exponential backoff and retry logic
  - `alert_manager.py` - Alert system implementation
- `src/core/scheduler/error_recovery.py` - Job recovery and failure analysis
- `tests/unit/test_shared/test_exceptions.py` - Exception handling tests
- `tests/unit/test_core/test_error_handling/` - Error handling module tests

**Files to Enhance:**

- `src/core/scheduler/tasks.py` - Add comprehensive error handling to existing tasks
- `src/core/crawler/engine.py` - Integrate circuit breaker for external service calls
- `src/database/repositories/job_repo.py` - Add failure analysis and recovery methods
- `src/shared/config.py` - Add error handling and alert configuration settings

**Error Handling Architecture:**

```python
# src/shared/exceptions.py
from enum import Enum
from typing import Optional, Dict, Any

class ErrorCode(str, Enum):
    # Business logic errors
    CATEGORY_NOT_FOUND = "CATEGORY_NOT_FOUND"
    CATEGORY_VALIDATION_FAILED = "CATEGORY_VALIDATION_FAILED"
    # External service errors  
    GOOGLE_NEWS_UNAVAILABLE = "GOOGLE_NEWS_UNAVAILABLE"
    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED"
    # Infrastructure errors
    CELERY_TASK_FAILED = "CELERY_TASK_FAILED"
    # Generic errors
    INTERNAL_SERVER_ERROR = "INTERNAL_SERVER_ERROR"

class BaseAppException(Exception):
    def __init__(
        self,
        code: ErrorCode,
        message: str,
        details: Optional[Dict[str, Any]] = None,
        retryable: bool = False,
        retry_after: Optional[int] = None
    ):
        self.code = code
        self.message = message
        self.details = details or {}
        self.retryable = retryable
        self.retry_after = retry_after
        super().__init__(message)
```

### Technical Constraints

**Source: [architecture/tech-stack.md] & [architecture/error-handling.md]**

**Retry Strategy Requirements:**

- **Exponential Backoff**: Base delay 1s, max delay 60s, exponential base 2.0
- **Jitter**: Add randomization (Â±50%) to prevent thundering herd
- **Maximum Retries**: Configurable per error type (default 3 for external services)
- **Rate Limit Handling**: Respect retry-after headers from external services

**Circuit Breaker Requirements:**

- **Failure Threshold**: 5 consecutive failures to open circuit
- **Recovery Timeout**: 5 minutes before attempting recovery
- **Half-Open Testing**: Single request to test service recovery
- **State Persistence**: Maintain circuit state across service restarts

**Alert System Requirements:**

- **Rate Limiting**: Maximum 10 alerts per hour per rule to prevent spam
- **Severity Levels**: LOW, MEDIUM, HIGH, CRITICAL with different handling
- **Channel Configuration**: Support multiple notification channels (email, webhook, log)
- **Alert History**: Track alert acknowledgments and resolution status

**Logging Requirements:**

- **Structured Format**: JSON logs with consistent field naming
- **Correlation IDs**: Track requests across all system components
- **Context Preservation**: Include job_id, task_id, category_id in all error logs
- **Error Classification**: Log error_code, retry_count, circuit_breaker_state

**Performance Requirements:**

- **Timeout Handling**: Configurable timeouts for external service calls
- **Resource Limits**: Prevent memory leaks from retry loops
- **Monitoring Integration**: Export metrics for circuit breaker states and error rates
- **Database Impact**: Minimize database writes during error conditions

### Testing Requirements

**Source: [architecture/testing-strategy.md]**

**Test Files to Create:**

- `tests/unit/test_shared/test_exceptions.py` - Exception class testing
- `tests/unit/test_core/test_error_handling/test_circuit_breaker.py` - Circuit breaker unit tests
- `tests/unit/test_core/test_error_handling/test_retry_handler.py` - Retry logic testing
- `tests/unit/test_core/test_error_handling/test_alert_manager.py` - Alert system testing
- `tests/integration/test_error_recovery.py` - Complete error recovery workflow testing

**Specific Testing Requirements:**

- Test error classification and exception hierarchy behavior
- Test exponential backoff with jitter for different failure patterns
- Test circuit breaker state transitions (closed â open â half-open â closed)
- Test alert rate limiting and channel configuration
- Test job recovery scenarios with different error types
- Test Celery task retry behavior with enhanced error handling
- Test external service failure simulation and recovery
- Test correlation ID propagation through error scenarios

**Mock Requirements for Testing:**

- Mock external service failures (Google News, newspaper4k)
- Mock database connection failures and recovery
- Mock Redis connectivity issues for Celery broker
- Mock circuit breaker state persistence
- Mock alert notification channels (email, webhook)
- Mock time progression for backoff and circuit breaker timeouts

### Project Structure Alignment

**Source: [architecture/source-tree.md]**

**New Directory Structure:**

```
src/core/error_handling/     # NEW - Error handling components
âââ __init__.py
âââ circuit_breaker.py       # Circuit breaker implementation
âââ retry_handler.py         # Exponential backoff logic
âââ alert_manager.py         # Alert system implementation
```

**Enhanced Files:**

- `src/shared/exceptions.py` - Add comprehensive error classification system
- `src/shared/config.py` - Add error handling configuration settings
- `src/core/scheduler/tasks.py` - Integrate enhanced error handling
- `src/core/crawler/engine.py` - Add circuit breaker for external calls
- `src/database/repositories/job_repo.py` - Add failure analysis methods

**Configuration Updates:**

- Add error handling settings to .env.example
- Add circuit breaker configuration parameters
- Add alert system configuration (channels, rate limits, severity mappings)
- Add retry strategy configuration (max_retries, backoff_multiplier, max_delay)

## Testing

**Test File Locations:**

- `tests/unit/test_shared/test_exceptions.py` - Exception handling unit tests
- `tests/unit/test_core/test_error_handling/` - Error handling module unit tests
- `tests/integration/test_error_recovery.py` - Complete error recovery integration tests

**Testing Frameworks:** pytest 7.4+ with pytest-asyncio for async operations, pytest-mock for mocking external dependencies

**Testing Strategy:**

- **Unit Testing**: Mock external dependencies and test error classification logic
- **Integration Testing**: Test complete error recovery workflows with real components
- **Failure Simulation**: Test various failure scenarios and recovery patterns
- **Performance Testing**: Verify retry logic doesn't cause resource exhaustion

**Key Test Scenarios:**

- Error classification and custom exception behavior
- Exponential backoff with jitter calculation accuracy
- Circuit breaker state transitions and timeout handling
- Alert system rate limiting and channel routing
- Job recovery with different error types and retry limits
- Celery task enhanced error handling integration
- External service failure recovery (Google News, newspaper4k)
- Database and Redis connection failure handling
- Correlation ID preservation through error scenarios
- Circuit breaker persistence across service restarts

## Dev Agent Record

### Completion Notes

Successfully implemented comprehensive error handling and retry logic system for Story 3.2:

**Core Components Delivered:**

1. **Enhanced Exception System** (`src/shared/exceptions.py`) - Complete error classification with retryable flags and error codes
2. **Circuit Breaker Implementation** (`src/core/error_handling/circuit_breaker.py`) - Full pattern with state management and metrics
3. **Retry Handler** (`src/core/error_handling/retry_handler.py`) - Exponential backoff with jitter and correlation tracking
4. **Alert System** (`src/core/error_handling/alert_manager.py`) - Multi-channel alerting with rate limiting
5. **Job Recovery Engine** (`src/core/scheduler/error_recovery.py`) - Automated failure analysis and recovery planning
6. **Enhanced Celery Tasks** (`src/core/scheduler/tasks.py`) - Comprehensive error handling with differentiated retry strategies

**Integration Points:**

- Updated `CrawlerEngine` with circuit breaker protection for Google News and article extraction
- Enhanced Celery tasks with structured error handling and alert notifications
- All components work together with correlation ID tracking for observability

**Testing Coverage:**

- Unit tests for all core components (exceptions, circuit breaker, retry handler, alerts)
- Integration tests for complete error recovery workflows
- Performance and resilience testing included

**All Acceptance Criteria Met:**
â AC1: Exponential backoff implemented with jitter and configurable limits
â AC2: Maximum retry limits per job with differentiated strategies
â AC3: Detailed error logging with correlation IDs throughout
â AC4: Circuit breaker pattern for persistent failures with state management
â AC5: Alert system for critical failures with rate limiting and multiple channels

### File List

**New Files Created:**

- `src/core/error_handling/__init__.py`
- `src/core/error_handling/circuit_breaker.py`
- `src/core/error_handling/retry_handler.py`
- `src/core/error_handling/alert_manager.py`
- `src/core/scheduler/error_recovery.py`
- `tests/unit/test_shared/test_exceptions.py`
- `tests/unit/test_core/test_error_handling/test_circuit_breaker.py`
- `tests/unit/test_core/test_error_handling/test_retry_handler.py`
- `tests/unit/test_core/test_error_handling/test_alert_manager.py`
- `tests/integration/test_error_recovery.py`

**Files Modified:**

- `src/shared/exceptions.py` - Enhanced with comprehensive error classification system
- `src/core/crawler/engine.py` - Integrated circuit breaker for external service calls
- `src/core/scheduler/tasks.py` - Enhanced Celery tasks with comprehensive error handling

### Agent Model Used

Sonnet 4 (claude-sonnet-4-20250514)

## QA Results

### Review Date: 2025-09-12

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

Exceptional implementation quality with comprehensive error handling architecture. The implementation demonstrates professional-grade resilience patterns including proper circuit breaker implementation, sophisticated retry logic with exponential backoff and jitter, and multi-channel alerting system. All code follows SOLID principles with excellent separation of concerns and async/await patterns throughout.

### Compliance Check

- Coding Standards: â Excellent adherence to async patterns, type hints, and documentation standards
- Project Structure: â Proper modular organization with clear separation of concerns
- Testing Strategy: â Comprehensive unit and integration test coverage with realistic failure scenarios
- All ACs Met: â All 5 acceptance criteria fully implemented with appropriate test validation

### Requirements Traceability

**AC1 (Exponential Backoff):** â Implemented with configurable jitter and correlation tracking

- Tests: `test_retry_handler.py` validates backoff calculations and jitter application
- Implementation: `RetryHandler.calculate_delay()` with proper exponential growth and jitter

**AC2 (Max Retry Limits):** â Differentiated retry strategies per error type with configurable limits

- Tests: Retry handler tests verify limit enforcement across error categories
- Implementation: Multiple retry configurations (EXTERNAL_SERVICE_RETRY, DATABASE_RETRY, RATE_LIMIT_RETRY)

**AC3 (Detailed Error Logging):** â Structured logging with correlation IDs and comprehensive context

- Tests: Exception tests verify error serialization and context preservation
- Implementation: All components include structured logging with correlation ID propagation

**AC4 (Circuit Breaker):** â Professional implementation with state management and recovery patterns

- Tests: `test_circuit_breaker.py` validates state transitions, metrics, and recovery timeouts
- Implementation: Full pattern with CLOSED/OPEN/HALF_OPEN states and async support

**AC5 (Critical Failure Alerts):** â Multi-channel alerting with rate limiting and severity levels

- Tests: `test_alert_manager.py` validates alert rules, rate limiting, and delivery channels
- Implementation: Complete system supporting EMAIL/WEBHOOK/LOG_ONLY with default rules

### Security Review

PASS - No security concerns identified. Error messages and logs properly sanitized with no credential exposure. Alert system uses proper authentication for external channels.

### Performance Considerations

PASS - Circuit breaker provides fail-fast patterns preventing cascade failures. Proper resource management with timeouts and async patterns. No memory leaks identified in retry loops.

### Integration Assessment

PASS - Excellent integration across all system components:

- CrawlerEngine properly uses circuit breaker for Google News and extraction calls
- Celery tasks enhanced with differentiated error handling and alert integration
- Repository layer includes proper database connection failure handling

### Gate Status

Gate: **PASS** â docs/qa/gates/3.2-error-handling-retry-logic.yml

### Recommended Status

â Ready for Done - Implementation exceeds expectations with enterprise-grade error handling patterns

## Change Log

| Date       | Version | Description                                             | Author                 |
| ---------- | ------- | ------------------------------------------------------- | ---------------------- |
| 2025-09-12 | v1.0    | Initial story creation for Error Handling & Retry Logic | Bob - Scrum Master     |
| 2025-09-12 | v2.0    | Story implementation completed - Ready for Review       | James - Dev Agent      |
| 2025-09-12 | v3.0    | QA Review completed - Ready for Done                    | Quinn - Test Architect |
